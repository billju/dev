<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A*</title>
</head>
<body>
    <svg id="maze"></svg>
    <div id="control-panel" style="position:fixed;top:0;right:0">
        <button onclick="nextStep()">start</button>
        <button onclick="clearMaze()">clear</button>
        <button onclick="resetMaze()">reset</button>
    </div>
</body>
<style>
    *{
        font-family: sans-serif;
    }
    html,body{
        margin: 0;
        height: 100%;
    }
    #maze{
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: relative;
    }
    .rect{
        position: absolute;
        background: #fff;
        border: 1px solid #000;
        box-shadow: 5px 5px 5px 0 #000;
        text-align: center;
        transform-origin: center;
        transition: transform 0.1s;
        font-size: 12px;
        user-select: none;
    }
    #control-panel{
        padding: 15px;
        border-radius: 5px;
        background: rgba(0,0,0,0.3);
        user-select: none;
    }
    text{
        user-select: none;
        font-size: 12px;
        font-family: sans-serif;
    }
</style>
<script>
class Node{
    constructor(point=[0,0]){
        this.point = point
        this.neighbors = []
        this.from = null
        this.isWall = false
        this.g = 0
        this.h = 0
        this.f = 0
    }
    isEqual(node){
        return this.point[0]==node.point[0]&&this.point[1]==node.point[1]
    }
    Manhattan(node){
        return Math.abs(this.point[0]-node.point[0])+Math.abs(this.point[1]-node.point[1])
    }
    Euclidean(node){
        return Math.pow(this.point[0]-node.point[0],2)+Math.pow(this.point[1]-node.point[1],2)
    }
    Chebyshev(node){
        return Math.max(Math.abs(this.point[0]-node.point[0]),Math.abs(this.point[1]-node.point[1]))
    }
    findNeighbors(dirs=[[0,1],[0,-1],[1,0],[-1,0]],nodes=Maze.nodes){
        this.neighbors = []
        for(let dir of dirs){
            let x = this.point[0]+dir[0]
            let y = this.point[1]+dir[1]
            if(x<0||x>=nodes.length)
                continue
            if(y<0||y>=nodes[0].length)
                continue
            if(nodes[x][y].isWall)
                continue
            this.neighbors.push(nodes[x][y])
        }
        return this.neighbors
    }
}
class Maze{
    constructor(container){
        this.container = container
        this.size = 30
        this.event = {active: false, fill: undefined, index: -1}
        this.nodes = []
        this.resize()
        this.createRects()
        this.createNodes()
        this.container.addEventListener('mousedown',e=>{
            this.event.active = true            
            this.render(e)
        })
        this.container.addEventListener('mousemove',e=>{
            this.render(e)
        })
        this.container.addEventListener('mouseup',e=>{
            this.event = {active: false, fill: undefined, index: -1}
        })
        this.container.addEventListener('mouseleave',e=>{
            this.event = {active: false, fill: undefined, index: -1}
        })
    }
    resize(){
        let W = this.container.clientWidth
        let H = this.container.clientHeight
        this.rows = Math.ceil(H/this.size)
        this.columns = Math.ceil(W/this.size)
        this.container.setAttribute('viewBox',`0 0 ${W} ${H}`)
    }
    createRects(){
        this.container.innerHTML = ''
        for(let i=0;i<this.columns;i++){
            for(let j=0;j<this.rows;j++){
                // let rect = document.createElement('div')
                // rect.className = 'rect'
                
                // Object.assign(rect.style,{
                //     left: i*this.size+'px',
                //     top: j*this.size+'px',
                //     width: this.size+'px',
                //     height: this.size+'px',
                //     lineHeight: this.size+'px',
                // })
                let rect = document.createElementNS('http://www.w3.org/2000/svg','rect')
                rect.dataset.fill = 'white'
                rect.setAttribute('x',i*this.size)
                rect.setAttribute('y',j*this.size)
                rect.setAttribute('width',this.size)
                rect.setAttribute('height',this.size)
                rect.setAttribute('stroke','black')
                rect.setAttribute('fill','white')
                rect.style.transition = 'transform 0.2s'
                this.container.appendChild(rect)
            }
        }
    }
    createText(node){
        let text = document.createElementNS('http://www.w3.org/2000/svg','text')
        text.setAttribute('x',node.point[0]*this.size+this.size/2)
        text.setAttribute('y',node.point[1]*this.size+this.size/2) 
        text.setAttribute('text-anchor','middle')
        text.setAttribute('dominant-baseline','middle')
        this.container.appendChild(text)
        return text
    }
    createNodes(){
        let dirs = [[0,1],[0,-1],[1,0],[-1,0]]
        for(let i=0;i<this.columns;i++){
            let row = []
            for(let j=0;j<this.rows;j++){
                row.push(new Node([i,j]))
            }
            this.nodes.push(row)
        }
    }
    getElementOfNode(node){
        let idx = node.point[0]*this.rows+node.point[1]
        return this.container.children[idx]
    }
    render(e){
        if(this.event.active){
            let dx = Math.floor((e.clientX-this.container.clientLeft)/this.size)
            let dy = Math.floor((e.clientY-this.container.clientTop)/this.size)
            let idx = dx*this.rows+dy
            let children = this.container.children
            let scale = 1.1, coef = this.size*(scale-1), pad = 5
            if(children[idx]&&this.event.index!=idx){
                if(this.event.fill===undefined)
                    this.event.fill = children[idx].dataset.fill=='white'?color.grey:'white'
                this.nodes[dx][dy].isWall = this.event.fill==color.grey
                children[idx].dataset.fill = this.event.fill
                children[idx].style.fill = children[idx].dataset.fill
                children[idx].style.transform = `matrix(${scale},0,0,${scale},${-dx*coef-pad},${-dy*coef-pad})`
                setTimeout(()=>{
                    children[idx].style.transform = 'matrix(1,0,0,1,0,0)'
                },200)
                this.event.index = idx
            }
        }
    }
}
class Astar{
    constructor(nodes=[],start=Node,end=Node){
        this.nodes = nodes
        this.curNode = start
        this.endNode = end
        this.unvisited = [this.curNode]
        this.visited = []
    }
    getPath(){
        let path = []
        let node = this.curNode
        while(node){
            path.push(node)
            node = node.from
        }
        return path.reverse()
    }
    nextStep(){
        if(this.unvisited.length==0) return 'infeasible'
        if(this.curNode.isEqual(this.endNode)) return 'finished'
        // extract the node which has the smallest f in unvisited
        this.unvisited.sort((a,b)=>a.f-b.f)
        this.curNode = this.unvisited.shift()
        this.visited.push(this.curNode)
        // update f value
        const dirs = [[0,1],[0,-1],[1,0],[-1,0]]//,[1,1],[-1,1],[1,-1],[-1,-1]]
        const neighbors = this.curNode.findNeighbors(dirs,this.nodes)
        for(let neighbor of neighbors){
            // if neighbor is visited
            if(neighbor.from) continue
            if(this.visited.some(node=>neighbor.isEqual(node))) continue
            neighbor.g = this.curNode.g + 1
            neighbor.h = neighbor.Euclidean(this.endNode)
            neighbor.f = neighbor.g + neighbor.h
            neighbor.from = this.curNode
            // if g value is not smaller
            if(this.unvisited.some(node=>neighbor.isEqual(node)&&neighbor.g>node.g)) continue
            this.unvisited.push(neighbor)
        }
        return 'not yet'
    }
    findSolution(){
        let msg = this.nextStep()
        while(msg=='not yet'){
            msg = this.nextStep()
        }
        // if(msg=='finished') return this.getPath()
        return msg
    }
}
const color = {
    blue: '#5DC3E2',
    green: '#D5F5E3',
    darkgreen: '#58D68D',
    red: '#F5B7B1',
    grey: '#5D6D7E',
    lime: '#5DE2BF'
}
const maze = new Maze(document.getElementById('maze'))
let startNode = maze.nodes[0][0]
let endNode = maze.nodes[10][10]
let astar = new Astar(maze.nodes,startNode,endNode)
var timeout = undefined
maze.getElementOfNode(startNode).style.fill = color.blue
maze.getElementOfNode(endNode).style.fill = color.red
function nextStep(){
    let msg = astar.nextStep()
    astar.unvisited.map(node=>{
        let rect = maze.getElementOfNode(node)
        rect.style.fill=color.green
        if(!node.text){
            node.text = maze.createText(node)
            node.text.textContent = node.f
        }
    })
    astar.visited.map(node=>maze.getElementOfNode(node).style.fill=color.darkgreen)  
    maze.getElementOfNode(startNode).style.fill = color.blue
    maze.getElementOfNode(endNode).style.fill = color.red
    maze.getElementOfNode(astar.curNode).style.fill = color.blue
    if(msg=='not yet'){
        timeout = setTimeout(()=>{
            nextStep()
        }, 50)
    }else if(msg=='finished'){
        astar.getPath().map(node=>{
            maze.getElementOfNode(node).style.fill = color.lime
            if(node.isEqual(startNode))
                maze.getElementOfNode(node).style.fill = color.blue
            if(node.isEqual(endNode))
                maze.getElementOfNode(node).style.fill = color.red
        })
    }else{
        alert('no feasible path')
    }
}

function clearMaze(){
    clearTimeout(timeout)
    astar = new Astar(maze.nodes,startNode,endNode)
    maze.nodes.flatMap(n=>n).map(node=>{
        let rect = maze.getElementOfNode(node)
        let isWall = node.isEqual(startNode)||node.isEqual(endNode)?false:Math.random()>0.7
        rect.style.fill = isWall?color.grey:'white'
        rect.dataset.fill = isWall?color.grey:'white'
        node.isWall = isWall
        node.from = null
        node.text = null
    })
    maze.container.querySelectorAll('text').forEach(text=>text.remove())
    maze.getElementOfNode(startNode).style.fill = color.blue
    maze.getElementOfNode(endNode).style.fill = color.red
}
function resetMaze(){
    startNode = maze.nodes[Math.floor(Math.random()*maze.columns)][Math.floor(Math.random()*maze.rows)]
    endNode = maze.nodes[Math.floor(Math.random()*maze.columns)][Math.floor(Math.random()*maze.rows)]
    clearMaze()
}
window.addEventListener('resize',()=>{
    maze.container.innerHTML = ''
    maze.nodes = []
    maze.resize()
    maze.createRects()
    maze.createNodes()
    if(maze.rows<=startNode.point[1]||maze.rows<=endNode.point[1]||maze.columns<=startNode.point[0]||maze.columns<=endNode.point[0])
        resetMaze()
    else
        clearMaze()
})
function makeElementMovable(element){
    // do not assign top,left,right,bottom in css class
    element.addEventListener('mousedown', e=>{
        element.dataset.dragging = true
        element.dataset.x = e.clientX
        element.dataset.y = e.clientY
    })
    window.addEventListener('mousemove', e=>{
        if(element.dataset.dragging=='true'){
            let left = element.offsetLeft+e.clientX-element.dataset.x
            let top = element.offsetTop+e.clientY-element.dataset.y
            if(left+element.clientWidth/2>=window.innerWidth/2){
                let right = window.innerWidth-left-element.clientWidth
                element.style.left = ''
                element.style.right = right+'px'
            }else{
                element.style.right = ''
                element.style.left = left+'px'
            }
            if(top+element.clientHeight/2>window.innerHeight/2){
                let bottom = window.innerHeight-top-element.clientHeight
                element.style.top = ''
                element.style.bottom = bottom+'px'
            }else{
                element.style.bottom = ''
                element.style.top = top+'px'
            }
            element.dataset.x = e.clientX
            element.dataset.y = e.clientY
        }
    })
    window.addEventListener('mouseup', e=>{
        element.dataset.dragging = false
    })
    window.addEventListener('mouseleave', e=>{
        element.dataset.dragging = false
    })
}
makeElementMovable(document.getElementById('control-panel'))
</script>
</html>