<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio</title>
</head>
<body>
    <input type="file" onchange="handleFile(event)">
    <canvas id="canvas"></canvas>
</body>
<style>
    html,body{
        margin: 0;
    }
    #canvas{
        width: 500px;
        height: 200px;
    }
</style>
<script>
async function handleFile(e){
    var file = e.target.files[0]
    if(file.type.includes('audio')){
        var decoder = new Decoder()
        var arrayBuffer = await decoder.readFile(file)
        var audioBuffer = await decoder.decode(arrayBuffer)
        // decoder.setSource(audioBuffer)
        var data = audioBuffer.getChannelData(0)
        // console.log(decoder.getPeaks(500,data))
        decoder.waveform(data)
    }
    
}
class Decoder{
    constructor(){
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)()
        this.bufferSource = this.audioContext.createBufferSource()
    }
    readFile(file){
        return new Promise(resolve=>{
            const reader = new FileReader()
            reader.readAsArrayBuffer(file)
            reader.onload = ()=>{
                resolve(reader.result)
            }
        })
    }
    decode(arrayBuffer){
        return this.audioContext.decodeAudioData(arrayBuffer)
    }
    setSource(audioBuffer){
        this.bufferSource.source = audioBuffer
    }
    getPeaks(width, data){
        const step = Math.floor(data.length/width)
        var peaks = new Array(width)
        var minPeak = 0, maxPeak = 0
        for(let i=0;i<width;i++){
            let batch = data.slice(i*step,(i+1)*step)
            let min = Math.min(...batch)
            let max = Math.max(...batch)
            minPeak = Math.min(min, minPeak)
            maxPeak = Math.max(max, maxPeak)
            peaks[i] = [min,max]
        }
        return peaks.map(peak=>([-peak[0]/minPeak, peak[1]/maxPeak]))
    } 
    waveform(data){
        const canvas = document.getElementById('canvas')
        const rect = canvas.getBoundingClientRect()
        canvas.height = rect.height
        canvas.width = rect.width
        const ctx = canvas.getContext('2d')
        var peaks = this.getPeaks(rect.width, data)
        var cy = rect.height/2
        var amp = rect.height/4
        redraw()
        var bound = {active:false,left:0,right:0,start:0}
        canvas.addEventListener('contextmenu',e=>{
            e.preventDefault()
        })
        function redraw(){
            ctx.clearRect(0,0,canvas.width,canvas.height)
            ctx.beginPath()
            ctx.moveTo(0,cy)
            peaks.map((peak,i)=>{
                ctx.lineTo(i,peak[0]*amp+cy)
                ctx.lineTo(i,peak[1]*amp+cy)
            })
            ctx.strokeStyle = 'black'
            ctx.lineWidth = 1
            ctx.stroke()
            ctx.closePath()
        }
        canvas.addEventListener('mousedown',e=>{
            var LEFT=1,MID=2,RIGHT=3
            if(e.which==RIGHT){
                bound.active = true
                bound.start = bound.left = bound.right = Math.floor(e.clientX-rect.left)
                redraw()
            }
        })
        canvas.addEventListener('mousemove',e=>{
            if(bound.active){
                let left = Math.floor(e.clientX-rect.left)
                redraw()
                if(left>bound.start){
                    bound.left = bound.start
                    bound.right = left
                }else{
                    bound.left = left
                    bound.right = bound.start
                }
                ctx.beginPath()
                ctx.moveTo(bound.left,0)
                ctx.lineTo(bound.left,rect.height)
                ctx.fillRect(bound.left-10,cy-15,10,30)
                ctx.fillStyle = 'grey'
                ctx.strokeStyle = 'grey'
                ctx.stroke()
                ctx.fill()
                ctx.closePath()

                ctx.fillRect(bound.right,cy-15,10,30)
                ctx.moveTo(bound.right,0)
                ctx.lineTo(bound.right,rect.height)
                ctx.fillStyle = 'grey'
                ctx.strokeStyle = 'grey'
                ctx.stroke()
                ctx.fill()
                ctx.closePath()

                ctx.beginPath()
                ctx.moveTo(bound.left,cy)
                peaks.slice(bound.left,bound.right).map((peak,i)=>{
                    let x = bound.left+i
                    ctx.lineTo(x,peak[0]*amp+cy)
                    ctx.lineTo(x,peak[1]*amp+cy)
                })
                ctx.strokeStyle = 'dodgerblue'
                ctx.lineWidth = 1
                ctx.stroke()
                ctx.closePath()
            }
        })
        canvas.addEventListener('mouseup',e=>{
            bound.active = false
        })
        canvas.addEventListener('mouseleave',e=>{
            bound.active = false
        })
    }
}
class Player{
    constructor(){
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)()
        this.analyser = this.audioContext.createAnalyser()
    }
    spectrogram(canvas) {
        var ctx = canvas.getContext('2d')
        const data = new Uint8Array(this.analyser.frequencyBinCount);
        const h = canvas.height / data.length;
        const x = canvas.width - 1;
        ctx.fillStyle = 'hsl(280, 100%, 10%)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        loop();
        function loop() {
            window.requestAnimationFrame(loop);
            let imgData = ctx.getImageData(1, 0, canvas.width - 1, canvas.height);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.putImageData(imgData, 0, 0);
            this.analyser.getByteFrequencyData(data);
            for (let i = 0; i < data.length; i++) {
                let rat = data[i] / 255;
                let hue = Math.round((rat * 120) + 280 % 360);
                let sat = '100%';
                let lit = 10 + (70 * rat) + '%';
                ctx.beginPath();
                ctx.strokeStyle = `hsl(${hue}, ${sat}, ${lit})`;
                ctx.moveTo(x, canvas.height - (i * h));
                ctx.lineTo(x, canvas.height - (i * h + h));
                ctx.stroke();
            }
        }
    }
}

class Encoder{
    constructor(){

    }
    encodeMP3(audioBuffer, smapleRate){
        // new an encoder: bitRate = 192
        const encoder = new Mp3LameEncoder(sampleRate, 192)
        encoder.encode(channels)
        const blob = encoder.finish()
        return blob
    }
    encodeWAV(audioBuffer, smapleRate){

    }
    sliceAudioBuffer(audioBuffer,start=0,end=audioBuffer.length){
        const newBuffer = audioCtx.createBuffer(
            audioBuffer.numberOfChannels,
            end - start,
            audioBuffer.sampleRate
        )
        for(let i=0;i<audioBuffer.numberOfChannels;i++){
            newBuffer.copyToChannel(audioBuffer.getChannelData(i).slice(start,end))
        }
        return newBuffer
    }
    download(blob){
        const url = URL.createObjectURL(blob)
        const link = document.createElement('a')
        link.href = url
        link.download = name
        document.body.appendChild(link)
        link.click()
        link.remove()
    }
}
</script>
</html>